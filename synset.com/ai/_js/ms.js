'use strict';
/****************************************************************************************
*                              Библиотека численных и матричных вычислений

                                             (с) 2017-Nov steps synset.com absolutist.com
****************************************************************************************/
function MS()
{
   this.PI2 = Math.PI*2;

   this.was  = false;                         // была ли вычислена пара чисел rndG()
   this.rndg = 0;                            // предыдущее случ.число из пары rndG()
}
/****************************************************************************************
*                                Математические функции                                 /
/*********************************`*******************************************************
* n*n (квадрат числа)
*/
MS.sqr = function(n)
{
   return n*n;
}
/****************************************************************************************
*                                Работа с векторами и матрицами                         /
/****************************************************************************************
* сумма чисел
*/
MS.sumV = function(ar)
{
   let s = 0;
   for(let i=0; i < ar.length; i++)
      s += ar[i];
   return s;
}
/****************************************************************************************
* минимальное число
*/
MS.minV = function(ar)
{
   let m = ar[0];
   for(let i=1; i < ar.length; i++)
      if(ar[i] < m)
         m=ar[i];
   return m;
}
/****************************************************************************************
* максимальное число
*/
MS.maxV = function(ar)
{
   let m = ar[0];
   for(let i=1; i < ar.length; i++)
      if(ar[i] > m)
         m=ar[i];
   return m;
}
/****************************************************************************************
* среднее значение
*/
MS.averV = function(ar)
{
   let s = 0;
   for(let i=0; i < ar.length; i++)
      s += ar[i];
   return s/ar.length;
}
/****************************************************************************************
* медиана
*/
MS.median = function(ar)
{
   ar.sort();
   let i = Math.floor(ar.length/2);
   if(ar.length % 2 > 0 )
      return ar[i];
   else{
      return (ar[i]+ar[i-1])/2;
   }

   let s = 0;
   for(let i=0; i < ar.length; i++)
      s += ar[i];
   return s/ar.length;
}
/****************************************************************************************
* Квадрат длины вектора 
*/
MS.normV = function (ar)
{
   let d2 = 0;
   for(let i=0; i < ar.length; i++)
      d2 += ar[i]*ar[i];
   return d2;
}
/****************************************************************************************
* Квадрат расстояния между двумя точками
*/
MS.normVV = function (ar1, ar2)
{
   let d2 = 0;
   for(let i=0; i < ar1.length; i++)
      d2 += (ar1[i]-ar2[i])*(ar1[i]-ar2[i]);
   return d2;
}
/****************************************************************************************
* Сложить два вектора ar=ar1+ar2, вернуть результат ar
*/
MS.addVV = function (ar, ar1, ar2)
{   
   for(let i=0; i < ar.length; i++)
      ar[i] = ar1[i]+ar2[i];
   return ar;
}
/****************************************************************************************
* Вычесть два вектора ar=ar1-ar2, вернуть результат ar
*/
MS.subVV = function (ar, ar1, ar2)
{   
   for(let i=0; i < ar.length; i++)
      ar[i] = ar1[i]-ar2[i];
   return ar;
}
/****************************************************************************************
* Добавить компоненты вектора ar2 в вектор ar1
*/
MS.incVV = function (ar1, ar2)
{
   for(let i=0; i < ar1.length; i++)
      ar1[i] += ar2[i];
   return ar1;
}
/****************************************************************************************
* Умножить компоненты вектора ar на скаляр val
*/
MS.multVS = function (ar, val)
{
   for(let i=0; i < ar.length; i++)
      ar[i] *= val;
   return ar;
}
/****************************************************************************************
* Скалярное произведение ar1 на ar2
*/
MS.multVV = function (ar1, ar2)
{
   let s = 0;
   for(let i=0; i < ar1.length; i++)
      s += ar1[i]*ar2[i];
   return s;
}
/****************************************************************************************
* Вернуть нулевой вектор
*/
MS.zeroV = function (ar)
{
   for(let i=0; i < ar.length; i++)
      ar[i] = 0;
   return ar;
}
/****************************************************************************************
* Присвоить ar1 = ar2;
*/
MS.setVV = function (ar1, ar2)
{
   for(let i=0; i < ar1.length; i++)
      ar1[i] = ar2[i];
   return ar1;
}
/****************************************************************************************
* Присвоить в ar число
*/
MS.setVS = function (ar, s)
{
   for(let i=0; i < ar.length; i++)
      ar[i] = s;
   return ar;
}
/****************************************************************************************
* Нормировать вектор
*/
MS.normalize = function (ar)
{
   let n = Math.sqrt(MS.normV(ar));
   for(let i=0; i < ar.length; i++)
      ar[i] /= n;
   return ar;
}
/****************************************************************************************
* Вернуть вектор со случайными компонентами
*/
MS.randV = function (ar, min, max)
{
   if(min===undefined)
      min = 0;
   if(max===undefined)
      max = 1;
   let d = max-min;
   
   for(let i=0; i < ar.length; i++)
      ar[i] = min + Math.random()*d;
   return ar;
}
/****************************************************************************************
* Вернуть вектор со случайными, нормально распределёнными компонентами
*/
MS.gaussV = function (ar, sigma)
{
   sigma = sigma || 1;      
   for(let i=0; i < ar.length; i++)
      ar[i] = MS.rndG()*sigma;
   return ar;
}
/****************************************************************************************
*                    Различные расстояния между n-мерными точками a и b                */
/****************************************************************************************
* Квадрат евклидового расстояния (a-b)^2
*/
MS.euclidDist2 = function (a, b)
{
   let d2=0;
   for(let i=0; i < a.length; i++)
      d2 += (a[i]-b[i])*(a[i]-b[i]);
   return d2;
}
/****************************************************************************************
* Квадрат евклидового расстояния, делённый на длины векторов (a-b)^2/(|a|*|b|)
*/
MS.euclidNormDist2 = function (a, b)
{
   let d2=0, a2=0, b2=0;
   for(let i=0; i < a.length; i++){
      d2 += (a[i]-b[i])*(a[i]-b[i]);
      a2 += a[i]*a[i];
      b2 += b[i]*b[i];
   }
   return d2/Math.sqrt(a2*b2);
}
/****************************************************************************************
* Квадрат евклидового расстояния, делённый на длины векторов (a/|a|-b/|b|)^2
*/
MS.euclidUnitDist2 = function (a, b)
{
   let a2=0, b2=0;
   for(let i=0; i < a.length; i++){
      a2 += a[i]*a[i];
      b2 += b[i]*b[i];
   }
   a2 = Math.sqrt(a2);
   b2 = Math.sqrt(b2)
   let d2=0;
   for(let i=0; i < a.length; i++){
      let ab = a[i]/a2-b[i]/b2; 
      d2 += ab*ab;
   }
   return d2;
}
/****************************************************************************************
* Косинус между векторами 1- a*b/(|a|*|b|)
*/
MS.euclidCos = function (a, b)
{
   let d2=0, a2=0, b2=0;
   for(let i=0; i < a.length; i++){
      d2 += a[i]*b[i];
      a2 += a[i]*a[i];
      b2 += b[i]*b[i];
   }
   return 1-d2/Math.sqrt(a2*b2);
}
/****************************************************************************************
*                                       Случайные числа                                */
/****************************************************************************************
* Целое случайное число от 0 до  n-1
*/
MS.rand = function (n)
{
   return Math.floor(Math.random()*n);
}
/****************************************************************************************
* гаусово случ.число (mean=0; sigma=1)
*/
MS.rndG = function ()
{
   if(this.was) { this.was=false; return this.rndg; }

   let s, v1, v2;                            // "Методы компьют.эксп. в тер.физике"
   do{                                       // Д.В. Хеерман,1990
      v1 = 2*Math.random()-1;                // стр.142 Алгоритм П1.5
      v2 = 2*Math.random()-1;
      s=v1*v1 + v2*v2;
   }while(s>=1.0 || s===0);

   this.was  = 1;
   this.rndg = v1*Math.sqrt(-2*Math.log(s)/s);// первое случ.число
   return v2*Math.sqrt(-2*Math.log(s)/s);     // второе случ.число
}
/****************************************************************************************
*  Linear Congruential Generator http://en.wikipedia.org/wiki/Numerical_Recipes
*  https://jsperf.com/native-and-non-native-random-numbers/10
*/
MS.lcg = (function() 
{
   let z=1, a=1664525, b=1013904223, m = 4294967296; // = 2^32
   return {
      seed   : function(val)   { z = val || Math.round(Math.random() * m); },
      rand   : function(bound) { return (z = (a*z + b) % m) % bound; },
      random : function()      { return (z = (a*z + b) % m) / m; }
  };
}());

